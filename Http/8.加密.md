



加密和编码





密码学



## 古代密码学

起源：古代战争-古代密码学

对信件进行加密



![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/Cipherstick.png)




加密，说的是将有意义的数据变成无意义的字符，这样，即使泄漏了，别人也无法知道



密码学的两个关键因素：

加密算法   和  密钥





替换式加密：

ABCDEFGHIJKLMNOPQ

一一对应为：

BCDEFGHIJKLMNOPQA

其实就是每个字母+1

那么，

GO HOME   加密后就是：

HP IPNF



当拿到密文（HP IPNF），然后对每个字母-1，就可以得到原文

这种方式，加密算法就是：替换每个字符；密钥是：码表。双方拿着一样的码表就可以了。









## 现代密码学



不止可以对文字进行加密，还可以用于任何二进制数据



### 对称加密


![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/symmetric_encryption.png)


使用密钥和加密算法，对原数据进行转换，得到的无意义的数据就是密文。再使用密钥和解密算法，对密文进行转换，就可以得到原数据了。

经典算法：DES   AES



DES 由于密钥太短，已经被弃用了，现在都是AES。



优秀的加密算法：使得破解者找不到比穷举法更好的破解密钥的方法，只能暴力破解，挨着试，并且破解的时间非常长，比如100年。







### 非对称加密

使用公钥对数据加密，得到密文。使用私钥对密文进行解密，拿到原数据。

![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/asymmetric_encryption.png)


RSA



非对称加密举例说明：

比如，通信的内容只有10个字符，  0123456789

原数据为：110

加密算法：  对每一个字符进行加法。

加密密钥：加4

解密密钥：加6



原数据：110

加密后：554

解密后：110

相当于一个循环。或者理解为溢出了。







对称加密不安全。

原因在于：双方需要持有相同的密钥。那么，就涉及到一个问题，一方需要将密钥告知另一方。在发送密钥的过程中，可能会有截获。因此是不安全的。

而非对称加密，加密密钥和解密密钥不同。加密密钥（公钥）可以对外开放提供，但解密密钥（私钥）不能提供出去。


![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/symmetric_encryption_not_security.png)



这里，AB想要互相通信，C 是坏人，在中间劫持。  A先把A的加密密钥（公钥）给出去，BC都拿到。 B把B的加密密钥（公钥）给出去，AC都拿到。

当，A想要给B发消息的时候，A就把原数据使用B的加密密钥（公钥）加密成密文，发出去。那B收到密文后，使用B的解密密钥（私钥）+相同的加密算法，就可以拿到原数据了。

而C，就算它拿到了B的加密密钥，并且它也知道加密算法，它也无法解密的。因为解密是要用B的私钥解密的。C不知道B的私钥。这是关键。



一般都是拿着对方的公钥加密成密文，然后发送给对方，对方收到后，拿着它自己的私钥解密。这样就是安全的了。



非对称加密，公钥和私钥是可以互相解密的。

公钥是可以依靠私钥计算出来的。因此，私钥一定不要公开。



## 数字签名与验证

![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/digital_signature.png)


举例：

我写了一个欠条：我欠小王100元钱。 这个是原数据。然后使用我的私钥，对这个欠条内容进行加密。加密后得到签名数据。别人拿着我的公钥，使用相同的加密算法，对签名数据进行验证，如果可以转换成原数据，那么就说明，这个签名数据确实是来自我的。因为 只有我有我的私钥，其他人造的数据，用我的公钥是无法验证的。

比如，有个人想造假：我欠小王200元。这个是原数据，他（坏人）**用一个私钥（注意：不是我的私钥，他拿不到我的私钥！）**生成一个签名数据。然后，使用我的公钥和相同的加密算法，对签名数据验证，是无法还原原数据的。这就是说明：这个签名数据是假的，不是我写的！



更常见的是这样。把原数据和签名数据都放出来，这样，原数据大家都能看到，然后谁需要验证，再对签名数据进行验证，将验证结果 与 原数据进行对比，一致的话就说明验证成功。

![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/digital_signature_2.png)






### 加密+签名（带有签名的加密数据）



![](https://cdn.jsdelivr.net/gh/fanshanhong/note-image/encryption_and_sign.png)


加密和签名一起使用，既保证数据安全，也保证数据的来源是可信任的。



上面一条线：使用对方的公钥（因为要让对方看，所以是用对方的公钥，这样对方拿到后，用他自己的私钥解密就能看了）对原数据进行加密，得到密文。对方拿到密文后，使用自己的私钥就可以解密，获取到原数据。

下面一条线：同时，使用自己的私钥对原数据进行签名，得到签名数据。对方拿到签名数据后，使用发送方的公钥来验证，可以得到原数据。

如果上下两条线得到的原数据结果一致，就表示这个消息确实是来自发送的，不是来自其他人的。因为其他人是造不出这个签名数据的！

如果签名数据是来自于其他坏人的，那接收方使用发送方的公钥就验证不了的。或者说，验证的结果肯定与原数据不一致。这样就可以判断：这个消息是否是来自于可信任的发送方。





经典算法：RSA  DSA

RSA 用于加密和签名都可以。  DSA 专门用于签名，主要是由于DSA对签名和验证的速度快。





