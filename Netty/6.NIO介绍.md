---

title: NIO介绍

date: 2020-01-11

categories: 

   - Netty
   - IO

tags: 

   - Netty 
   - 网络
   - IO 

description: ​

---

<!-- TOC -->

- [介绍](#介绍)
- [为什么 NIO 是同步非阻塞的？](#为什么-nio-是同步非阻塞的)

<!-- /TOC -->


# 介绍

1. Java NIO 同步非阻塞IO（Non-Blocking IO），又称New IO， 是指JDK1.4开始，Java提供的一系列改进的输入输出新特性，被统称为NIO，是同步非阻塞的。
2. NIO相关的类置于 java.nio 包下。
3. NIO的三大要素

   * Channel

   * Buffer

   * Selector

4. NIO 是面向缓冲区（面向块）编程的。**程序不直接读写 Channel， 都要通过Buffer来操作**


# 为什么 NIO 是同步非阻塞的？

* 参考1：


> 按照《Unix网络编程》的划分，IO模型可以分为：阻塞IO、非阻塞IO、IO复用、信号驱动IO和异步IO，按照POSIX标准来划分只分为两类：同步IO和异步IO。
> 
> 如何区分呢？
> 
> 首先一个IO操作(read/write系统调用)其实分成了两个步骤：1)发起IO请求和2)实际的IO读写(内核态与用户态的数据拷贝)
> 
> 阻塞IO和非阻塞IO的区别在于第一步，发起IO请求的进程是否会被阻塞，如果阻塞直到IO操作完成才返回那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。
> 
> 同步IO和异步IO的区别就在于第二步，实际的IO读写(内核态与用户态的数据拷贝)是否需要进程参与，如果需要进程参与则是同步IO，如果不需要进程参与就是异步IO。
> 
> 如果实际的IO读写需要请求进程参与，那么就是同步IO。因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，在编程上，这种非阻塞IO一般都采用IO状态事件+回调方法的方式来处理IO操作。
> 
> 如果是同步IO，则状态事件为读写就绪。此时的数据仍在内核态中，但是已经准备就绪，可以进行IO读写操作。如果是异步IO，则状态事件为读写完成。此时的数据已经存在于应用进程的地址空间（用户态）中。
> 
> 这里的同步异步指的是真正io操作（即：从内核向进程复制数据）是否需要进程参与。这里所说的进程参与，指的是进程占用CPU执行数据拷贝的指令。
> 
> 作者：祖春雷
链接：https://www.zhihu.com/question/56673416/answer/150007232
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



* 参考2：
> 作者：知乎用户
链接：https://www.zhihu.com/question/56673416/answer/249461902
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


* 参考3：
[IO的旅程](https://mp.weixin.qq.com/s/fMaevGl0Qg25wfQ8uXqvEw)

* 参考4：
[Linux IO模式及 select、poll、epoll详解](https://www.cnblogs.com/natian-ws/p/10785649.html)

* 参考5：
> 作者：萧萧
链接：https://www.zhihu.com/question/19732473/answer/241673170
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

* 参考6：
> 作者：银月游侠
链接：https://www.zhihu.com/question/19732473/answer/88599695
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
> 
> 这几个概念，上面不少答案已经写得很清楚了。这里我结合自己的理解，简单地聊一下为什么这几个概念容易混淆。如果有错误之处，恳请批评指正。
> 
> 我认为同步、异步、阻塞、非阻塞，是分3个层次的：
> 
> CPU层次；
> 线程层次；
> 程序员感知层次。
> 
> 
> 这几个概念之所以容易混淆，是因为没有分清楚是在哪个层次进行讨论。
> 
> CPU层次
> 
> 在CPU层次，或者说操作系统进行IO和任务调度的层次，现代操作系统通常使用异步非阻塞方式进行IO（有少部分IO可能会使用同步非阻塞轮询），即发出IO请求之后，并不等待IO操作完成，而是继续执行下面的指令（非阻塞），IO操作和CPU指令互不干扰（异步），最后通过中断的方式来通知IO操作完成结果。
> 
> 线程层次
> 
> 在线程层次，或者说操作系统调度单元的层次，操作系统为了减轻程序员的思考负担，将底层的异步非阻塞的IO方式进行封装，把相关系统调用（如read，write等）以同步的方式展现出来。然而，同步阻塞的IO会使线程挂起，同步非阻塞的IO会消耗CPU资源在轮询上。为了解决这一问题，就有3种思路：
> 
> 多线程（同步阻塞）；
IO多路复用（select，poll，epoll）（同步非阻塞，严格地来讲，是把阻塞点改变了位置）；
直接暴露出异步的IO接口，如kernel-aio和IOCP（异步非阻塞）。
> 
> 程序员感知层次
> 
> 在Linux中，上面提到的第2种思路用得比较广泛，也是比较理想的解决方案。然而，直接使用select之类的接口，依然比较复杂，所以各种库和框架百花齐放，都试图对IO多路复用进行封装。此时，库和框架提供的API又可以选择是以同步的方式还是异步的方式来展现。如python的asyncio库中，就通过协程，提供了同步阻塞式的API；如node.js中，就通过回调函数，提供了异步非阻塞式的API。
> 
> 总结
> 
> 因此，我们在讨论同步、异步、阻塞、非阻塞时，必须先明确是在哪个层次进行讨论。比如node.js，我们可以说她在程序员感知层次提供了异步非阻塞的API，也可以说在Linux下，她在线程层次以同步非阻塞的epoll来实现。

----

Unix 系统下，不论是标准输入还是借助套接字接受网络输入，都有两个步骤：

1. 等待数据准备好**(Waiting for the data to be ready)**
2. 从内核向进程复制数据**(Copying the data from the kernel to the process)**


对于套接字（socket）而言，这两步是：

1. 等待网络上的数据分组到达；
2. 把数据从内核缓冲区复制到应用进程缓冲区中；


举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。

传统的BIO里面，用户进程调用方法 `socket.read()`， 底层是发起了read这个系统调用：

1. 首先，用户进程通过 `read()` 函数向内核（kernel）发起系统调用，即：用户进程告诉操作系统：我要读取数据了，请给我准备数据。说完，上下文从用户态（user space）切换为内核态（kernel space），内核就开始了IO的第一个阶段：准备数据。在第一个阶段中，内核一直等待网络数据到达。而在用户进程这边，用户进程就只能一直傻傻的等待。不论是对于用户进程而言，还是对于内核而言，都是阻塞的。
2. 第二阶段。当有网络数据到达内核缓冲区。内核再将数据从内核缓冲区拷贝到用户缓冲区中，然后`read()`系统调用返回，此时用户解除阻塞状态。

说的多一点：网络数据应该是先到达网卡缓冲区。一般是由DMA将数据从网卡缓冲区拷贝到内核缓冲区。然后DMA会向内核发出读完的信号，内核再将数据从内核缓冲区拷贝到用户缓冲区。全部拷贝完成后，`read()`系统调用返回，切换到用户空间，用户进程解除阻塞。

显然，第二个阶段是同步的。就是当数据准备好了，真正的读数据操作（即：从内核向进程复制数据），还是要内核自己来拷贝，指的是：进程占用CPU执行数据拷贝。


对于NIO来说，它是同步非阻塞的。
在第二个阶段，真正的读数据操作（即：从内核向进程复制数据），与阻塞的IO是相同的。
差别在于第一个阶段，如果数据没有到达，进程和内核都不会阻塞，而是直接返回0。
下面的代码可以验证，在  isAcceptable 条件下，肯定是没有数据可读的，但是在代码块中的最后， 直接调用了 `socketChannel.read(byteBuffer);`。这个  `read `方法直接返回0。

```java
if (key.isAcceptable()) { // 表示客户端来连接的事件已经就绪,此时我们调用accept不会阻塞
                    // 这个if条件好像也能这么写.
                    // key.interestOps() == SelectionKey.OP_ACCEPT

                    SocketChannel socketChannel = ((ServerSocketChannel) key.channel()).accept();//socketChannel是SocketCHannelImpl@634
                    socketChannel.configureBlocking(false);

                    // 将这个与客户端的通道也注册到selector上, 让它帮我们检测, 有数据的时候, 也通知我们一下
                    socketChannel.register(selector, SelectionKey.OP_READ);
                    // 给这个channel添加一个attachment(关联对象), 比如我们在这里给它关联了一个buffer, 后续它就能获取到这个buffer开始用了
                    // 个人认为没有必要??
                    // socketChannel.register(selector, SelectionKey.OP_READ, buffer);

                    // 可以在register之后观察一下selector.keys() 的变化
                    // register之后, keys元素是2个. keys[1] 是 SocketCHannelImpl@634, remote是127.0.0.1:52772, 显然代表客户端Channel

                    ByteBuffer byteBuffer = ByteBuffer.allocate(24);
                    socketChannel.read(byteBuffer);
                    System.out.println("客户端说:" + new String(byteBuffer.array()));

                } 
```


总结：
用户进程发起请求从内核中获取数据那么这时候有两种情况：

操作系统还没有准备后数据，那么这时候怎么办，有两种方法：
　　　　　　　　a. 让用于进程等着（这种情况就是阻塞）

　　　　　　　　b. 如果没有数据就返回一个ERROR，不需要用户进程干等（这种情况就是非阻塞）

过了一会儿操作系统准备好数据了，这时候又有两种方法：
　　　　　　　　a. 啥也不管，等着用户进程再次来请求才把数据给它（这种情况就是同步）

　　　　　　　　b. 负责到底，数据准备好，直接给到用户进程，并且还发出一个信号，告诉用户进程数据已经准备好（这种情况就是异步）

因此，我们可以发现：不管是阻塞IO，还是非阻塞IO都是同步IO。





