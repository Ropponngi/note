---

title: 11.Android Gradle插件

date: 2021-01-28

categories: 

   - Gradle

tags: 

   - Gradle 

description: ​
---


<!-- TOC -->

- [Android Gradle 分类](#android-gradle-分类)
- [Android 插件属性介绍](#android-插件属性介绍)
    - [android{}](#android)
    - [compileSdkVersion](#compilesdkversion)
    - [buildToolVersion](#buildtoolversion)
    - [defaultConfig](#defaultconfig)
        - [applicationId](#applicationid)
        - [minSdkVersion](#minsdkversion)
        - [targetSdkVersion](#targetsdkversion)
        - [versionCode和versionName](#versioncode和versionname)
        - [signingConfig](#signingconfig)
    - [配置签名信息](#配置签名信息)
    - [buildType](#buildtype)
        - [BuildType.java提供的属性](#buildtypejava提供的属性)
            - [javaCompileOptions](#javacompileoptions)
            - [shrinkResources](#shrinkresources)
        - [父类DefaultBuildType.java提供的属性](#父类defaultbuildtypejava提供的属性)
            - [mDebuggable](#mdebuggable)
            - [mJniDebuggable](#mjnidebuggable)
            - [mMinifyEnabled](#mminifyenabled)
            - [mSigningConfig](#msigningconfig)
            - [mZipAlignEnabled](#mzipalignenabled)
        - [在 父类BaseConfigImpl中，还有一些属性](#在-父类baseconfigimpl中还有一些属性)
            - [mProguardFiles](#mproguardfiles)
            - [mManifestPlaceholders](#mmanifestplaceholders)
            - [mMultiDexEnabled](#mmultidexenabled)
    - [使用混淆](#使用混淆)
    - [共享库](#共享库)
    - [批量修改APK文件名](#批量修改apk文件名)
    - [修改 build 目录](#修改-build-目录)
    - [动态版本信息](#动态版本信息)
    - [动态配置 AndroidManifest 文件](#动态配置-androidmanifest-文件)
    - [Java 编译选项](#java-编译选项)
- [Android Gradle 任务](#android-gradle-任务)

<!-- /TOC -->

# Android Gradle 分类

Android 有三类工程:

* APP应用工程，可以生成一个可运行的APK
* Library 库工程，可以生成aar包，给其他工程使用
* Test 测试工程，用于对APP或者Library进行单元测试

针对Android的三类工程，Android Gradle 提供了三个插件

* APP插件，id：com.android.application
* Library插件，id：com.android.library
* Test插件，id：com.android.test

这样我们就能明白，平常在我们app工程下的build.gradle 第一行总是：
`apply plugin: 'com.android.application'`


在一个库工程下的build.gradle文件第一行总是：
`apply plugin: 'com.android.library'`


按照我们之前讲的，要使用一个第三方插件，步骤是：
1. dependencies
2. repositories
3. apply


现在我们知道apply了，那在哪里配置  dependencies  和 repositories


在根目录下的build.gradle中
```groovy
buildscript {
    repositories {
        google()
        jcenter()
        
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.5.2'
        
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}
```

关于 buildscript 我们知道，

1. buildscript 配置的 是gradle脚本自身需要使用的资源。
2. gradle在执行脚本时，会优先执行buildscript代码块中的内容，然后才会执行剩余的build脚本。

这里我们配置在 buildscript 的就是 Android Gradle 脚本自身执行需要用的的资源。

dependencies 指定我们依赖的是哪个第三方库，然后repositories指定要去哪个仓库下载。


buildscript 写在根工程之后，所有的子工程就不用重复配置了。要不的话，需要给每个子工程的build.gradle都配置这个。


# Android 插件属性介绍 


```groovy
apply plugin: 'com.android.application'

android {
    compileSdkVersion 28
    buildToolsVersion "28.0.3"
    defaultConfig {
        applicationId "cc.ewell.mobile.drugapp" // 这个是配置属性,可以用=,也可以不加=.  其实是调用了setApplicationId 方法
        minSdkVersion 22 // 这个是方法调用,调用了minSdkVersion
        targetSdkVersion 28
        versionCode 7
        versionName "1.4.4"
        flavorDimensions "versionCode"
    }
```

## android{}

android{} 是Android Gradle插件提供的一个Project的扩展。具体看：https://github.com/fanshanhong/note/blob/master/Gradle/5.%20Extension%E8%AF%A6%E8%A7%A3.md

**Android Gradle的工程配置，都是在android{} 中，这是唯一的入口。通过它，可以对Android Gradle 进行自定义配置，具体实现是  com.android.build.gradle.AppExtension，是Project的一个扩展。**

这个一定要明确。android对象就是 AppExtension， 它的父类是 BaseExtension。这两个类为他们提供了很多的配置方法。

创建原型如下：

```groovy
extension = project.extensions.create('android', getExtensionClass(),(ProjectInternal)project, instantiator, androidBuilder, sdkHandler, buildTypeContainer, productFlavorContainer, signingConfigContainer, extraModeInfo, isLibrary())
```

显然，是用了创建Extension的这个方法：
```groovy
//创建Extension
<T> T create​(String name, Class<T> type, Object... constructionArguments)
```

指定了扩展的名字就是 android， 然后类型是 getExtensionClass()的返回值。

在com.android.application插件中， getExtensionClass()返回值就是  com.android.build.gradle.AppExtension 类型。因此，我们在android 这个扩展中配置的内容，其实就是  AppExtension 的属性。

## compileSdkVersion

配置我们编译Android工程的SDK版本。 这里是在调用  compileSdkVersion 方法。我们知道在groovy中，方法调用括号可以省略。

原型是:
```groovy
    /** @see #getCompileSdkVersion() */
    public void compileSdkVersion(String version) {
        checkWritability();
        this.target = version;
    }
        /** @see #getCompileSdkVersion() */
    public void compileSdkVersion(int apiLevel) {
        compileSdkVersion("android-" + apiLevel);
    }
```

传入int或者String都可以。如果用String的话这样写

```groovy
android {
   compileSdkVersion 'android-28'
}
```

此外，还有set方法。set方法内部也是调用了 上面的 compileSdkVersion 方法。

```groovy
    public void setCompileSdkVersion(int apiLevel) {
        compileSdkVersion(apiLevel);
    }

    public void setCompileSdkVersion(String target) {
        compileSdkVersion(target);
    }
```

如果使用set方法的话：

```
android {
   android.compileSdkVersion = 28 // 这样就调用set方法，像Dart一样。
}
```


## buildToolVersion

buildToolsVersion 设定使用的Android构建工具的版本。我们可以在Android SDK的目录中看到，它是一个工具包，包括appt， dex等。

原型 
```java
    public void buildToolsVersion(String version) {
        checkWritability();
        //The underlying Revision class has the maven artifact semantic,
        // so 20 is not the same as 20.0. For the build tools revision this
        // is not the desired behavior, so normalize e.g. to 20.0.0.
        buildToolsRevision = Revision.parseRevision(version, Revision.Precision.MICRO);
    }

```

有set方法和get方法
```java
    /** {@inheritDoc} */
    @Override
    public String getBuildToolsVersion() {
        return buildToolsRevision.toString();
    }

    public void setBuildToolsVersion(String version) {
        buildToolsVersion(version);
    }
```

因此我们可以通过 buildToolsVersion 方法给它赋值，也可以通过setBuildToolsVersion()方法富智，也可以通过android.buildToolsVersion这个属性来读取它的值。


## defaultConfig

defaultConfig 是一些默认配置。它是一个 ProductFlavor。 ProductFlavor 允许我们根据不同的情况同时生成多个不同的APK包。
如果一个ProductFlavor没有被特殊定义的话，默认就会使用defaultConfig中配置的内容

我们看下代码中，defaultConfig的原型是：
```java
    /**
     * Specifies defaults for variant properties that the Android plugin applies to all build
     * variants.
     *
     * <p>You can override any <code>defaultConfig</code> property when <a
     * href="https://developer.android.com/studio/build/build-variants.html#product-flavors">
     * configuring product flavors</a>.
     *
     * <p>For more information about the properties you can configure in this block, see {@link
     * ProductFlavor}.
     */
    public void defaultConfig(Action<DefaultConfig> action) {
        checkWritability();
        action.execute(defaultConfig);
    }
```

我们在build.gradle 中写 defaultConfig，其实是在调用上面的这个方法。

这同我们在 Extension 中讲的，创建嵌套Extension是一致的。这个defaultConfig就相当于android Extension的嵌套Extension。因此，要在android 这个对象（即：AppExtension）中，添加defaultConfig(...)这个方法。

实际上，defaultConfig(...)这个方法是BaseExtension类中的。

`AppExtension extends BaseExtension` 。这样就理解了。

查看代码，我们看到  
```java
/** DSL object for the defaultConfig object. */
@SuppressWarnings({"WeakerAccess", "unused"}) // Exposed in the DSL.
public class DefaultConfig extends BaseFlavor {
    @Inject
    public DefaultConfig(
            @NonNull String name,
            @NonNull Project project,
            @NonNull ObjectFactory objectFactory,
            @NonNull DeprecationReporter deprecationReporter,
            @NonNull Logger logger) {
        super(name, project, objectFactory, deprecationReporter, logger);
    }
}


/** Base DSL object used to configure product flavors. */
public abstract class BaseFlavor extends DefaultProductFlavor implements CoreProductFlavor {}

public class DefaultProductFlavor extends BaseConfigImpl implements ProductFlavor {
    private static final long serialVersionUID = 1L;
}
```

因此，上面说，defaultConfig 是一个 ProductFlavor

我们经常看到的配置，都是存在于DefaultProductFlavor中和BaseFlavor中。


下面是我们在 defaultConfig中经常配置的一些属性：


### applicationId
applicationId，指定包名。它是 DefaultProductFlavor的一个属性：mApplicationId，用于指定生成的App的包。这里配置 applicationId，实际是调用DefaultProductFlavor的方法：
```java
    @NonNull
    public ProductFlavor setApplicationId(String applicationId) {
        mApplicationId = applicationId;
        return this;
    }
```

### minSdkVersion

minSdkVersion，表示最低支持的android系统版本。如果要安装的系统低于这个版本，就会提示无法安装。它实际是调用BaseFlavor的方法：`minSdkVersion(int minSdkVersion)`。我们前面说过，当set方法和 minSdkVersion 都存在的时候，是调用 minSdkVersion 方法的。如果minSdkVersion 方法没有，只有set方法，那就是调用set方法的。
```java
    public void setMinSdkVersion(int minSdkVersion) {
        setMinSdkVersion(new DefaultApiVersion(minSdkVersion));
    }

    /**
     * Sets minimum SDK version.
     *
     * <p>See <a href="http://developer.android.com/guide/topics/manifest/uses-sdk-element.html">
     * uses-sdk element documentation</a>.
     */
    public void minSdkVersion(int minSdkVersion) {
        setMinSdkVersion(minSdkVersion);
    }
```

### targetSdkVersion

targetSdkVersion，表示我们是基于哪个Android版本开发的。实际是调用BaseFlavor的targetSdkVersion方法
```java
    @NonNull
    public com.android.builder.model.ProductFlavor setTargetSdkVersion(int targetSdkVersion) {
        setTargetSdkVersion(new DefaultApiVersion(targetSdkVersion));
        return this;
    }

    /**
     * Sets the target SDK version to the given value.
     *
     * <p>See <a href="http://developer.android.com/guide/topics/manifest/uses-sdk-element.html">
     * uses-sdk element documentation</a>.
     */
    public void targetSdkVersion(int targetSdkVersion) {
        setTargetSdkVersion(targetSdkVersion);
    }
```


### versionCode和versionName


versionCode，APP内部版本号，一般用于App升级。


versionName，App应用的版本名称，用户可以看到，就是我们发布的版本。

实际是调用DefaultProductFlavor中的方法
```java
    /**
     * Sets the version code.
     *
     * @param versionCode the version code
     * @return the flavor object
     */
    @NonNull
    public ProductFlavor setVersionCode(Integer versionCode) {
        mVersionCode = versionCode;
        return this;
    }

        /**
     * Sets the version name.
     *
     * @param versionName the version name
     * @return the flavor object
     */
    @NonNull
    public ProductFlavor setVersionName(String versionName) {
        mVersionName = versionName;
        return this;
    }

```

versionCode 和 versionName区别，参考：
https://github.com/fanshanhong/note/blob/master/Android/versionName%E5%92%8CversionCode.md



### signingConfig

配置默认的签名信息，对生成的APK进行签名。它是DefaultProductFlavor的属性`    private SigningConfig mSigningConfig;`。我们对它进行配置的时候，实际是调用了 set方法。
```java
    /**
     * Signing config used by this product flavor.
     */
    @Override
    @Nullable
    public SigningConfig getSigningConfig() {
        return mSigningConfig;
    }

    /** Sets the signing configuration. e.g.: {@code signingConfig signingConfigs.myConfig} */
    @NonNull
    public ProductFlavor setSigningConfig(SigningConfig signingConfig) {
        mSigningConfig = signingConfig;
        return this;
    }
```

## 配置签名信息

一般，App有Debug和Release两种模式。

debug模式的签名，是Android SDK 给我们提供的默认的，放在 $HOME/.android/debug.keystore

release默认的签名，要我们自己配置。

Android Extension 提供了 signingConfigs{} 便于我们配置多个签名。

看过之前的 Extension相关内容，我们知道， signingConfigs 就是 android（AppExtension） 的一个方法 signingConfigs(...)，方法里面是： action.execute(...)。这样才能生成一个嵌套的Extension。

我们去看一下源代码中是不是这样实现的：

BaseExtension.java中
```java
    /**
     * Encapsulates signing configurations that you can apply to {@link
     * com.android.build.gradle.internal.dsl.BuildType} and {@link ProductFlavor} configurations.
     *
     * <p>For more information about the properties you can configure in this block, see {@link
     * SigningConfig}
     */
    public void signingConfigs(Action<? super NamedDomainObjectContainer<SigningConfig>> action) {
        checkWritability();
        action.execute(signingConfigs);
    }

```

下面代码可以看到， signingConfigs 类型是 NamedDomainObjectContainer， 也就是个容器，这样我们在 signingConfigs{} 块中定义的都是一个一个的SignConfig对象。一个SigningConfig对象就是一个签名配置。

```java
 private final NamedDomainObjectContainer<SigningConfig> signingConfigs;
```

因为 这里是 NamedDomainObjectContainer，所有 SigningConfig 的构造必须制定name， 且只能存在一个参数的构造，我们看一下：
```java

/**
 * DSL object for configuring signing configs.
 */
public class SigningConfig extends DefaultSigningConfig implements Serializable, Named,
        CoreSigningConfig {
    private static final long serialVersionUID = 1L;

    /**
     * Creates a SigningConfig with a given name.
     *
     * @param name the name of the signingConfig.
     */
    @Inject
    public SigningConfig(@NonNull String name) {
        super(name);
    }
```

SigningConfig 可配置的元素如下：

* storeFile 签名文件证书
* storePassword 签名证书文件密码
* storeType 签名证书类型
* keyAlias 签名证书中密钥别名
* keyPassword 密钥密码

这几个元素都是 SigningConfig的属性，配置的时候其实是调用对应的set方法：
```java
public class SigningConfig extends DefaultSigningConfig implements Serializable, Named,
        CoreSigningConfig {}
```

DefaultSigningConfig.java
```java
 @NonNull
    public DefaultSigningConfig setStorePassword(String storePassword) {
        mStorePassword = storePassword;
        return this;
    }

    @Override
    @Nullable
    public String getKeyAlias() {
        return mKeyAlias;
    }

    @NonNull
    public DefaultSigningConfig setKeyAlias(String keyAlias) {
        mKeyAlias = keyAlias;
        return this;
    }

    @Override
    @Nullable
    public String getKeyPassword() {
        return mKeyPassword;
    }

    @NonNull
    public DefaultSigningConfig setKeyPassword(String keyPassword) {
        mKeyPassword = keyPassword;
        return this;
    }

    @Override
    @Nullable
    public String getStoreType() {
        return mStoreType;
    }

    @NonNull
    public DefaultSigningConfig setStoreType(String storeType) {
        mStoreType = storeType;
        return this;
    }
```

现在我们配置2个签名。
```groovy
android {
   signingConfigs {
        release {
            keyAlias 'keyalias'
            keyPassword '456'
            storeFile file('xx.keystore')
            storePassword '123'
        }

        debug {
            keyAlias 'keyalias-debug'
            keyPassword '456'
            storeFile file('xx-debug.keystore')
            storePassword '123'
        }
    }
}
```

现在只是生成了两个SignConfig实例，一个变量名是 release，一个变量名是 debug。如果需要使用，直接引用即可。比如在 defaultConfig中可以配置 signingConfig

```groovy
android {
   defaultConfig {
      signingConfig signingConfigs.debug
   }
}
```

调用的方法原型是 defaultConfig 中的  setSigningConfig方法
```java
    @NonNull
    public ProductFlavor setSigningConfig(SigningConfig signingConfig) {
        mSigningConfig = signingConfig;
        return this;
    }
```

上面可以看到，我们在 defaultConfig 中对签名配置的使用，这里`signingConfig signingConfigs.debug`中的signingConfigs 实际是 android(AppExtesion/BaseExtension)的一个属性，对应的方法是 getSigningConfigs()。


BaseExtension.java
```java
 /** {@inheritDoc} */
    @Override
    public NamedDomainObjectContainer<SigningConfig> getSigningConfigs() {
        return signingConfigs;
    }
```

现在我们把下面这个代码用Java写一下

```groovy
android {
   defaultConfig {
      signingConfig signingConfigs.debug
   }
}
```

等价于：

```java
defaultConfig.setSigningConfig(android.getSigningConfigs().get('debug'))
```


除了在 defaultConfig中指定签名信息，还可以对构建的类型分别指定签名信息。

```groovy
android {
   buildTypes {
      release {
         signingConfig signConfigs.release
      }

      debug {
          signingConfig signConfigs.debug
      }
   }
}
```

## buildType


buildTypes 用于指定不同的构建类型。在Android Gradle中，帮我们内置了 debug 和 release 两个构建类型。如果想增加新的构建类型，在 buildTypes{}中继续添加新的元素即可。

```groovy
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release

        }
        debug {

        }
        release222 {
            signingConfig signingConfigs.debug

        }
    }
```


buildTypes 是android(AppExtension/BaseExtension)一个 属性。类型是：NamedDomainObjectContainer ，就是一个集合，里面配置一个一个的 BuildType对象。

BaseExtension.java

```java
   private final NamedDomainObjectContainer<BuildType> buildTypes;
```

NamedDomainObjectContainer参考：https://github.com/fanshanhong/note/blob/master/Gradle/6.%20NamedDomainObjectContainer%E8%AF%A6%E8%A7%A3.md


那，在 BuildType对象中，有哪些可以配置呢。我们知道，配置，其实要么就是调用对应的方法，或者调用属性的set方法。我们看下源码

### BuildType.java提供的属性

```java
public class BuildType extends DefaultBuildType implements CoreBuildType, Serializable {
    ...
    @NonNull private final NdkOptions ndkConfig;
    @NonNull
    private final com.android.build.gradle.internal.dsl.JavaCompileOptions javaCompileOptions;
    @Nullable private PostProcessingConfiguration postProcessingConfiguration;
    @Nullable private String postProcessingDslMethodUsed;
    private boolean shrinkResources = false;
    private Boolean useProguard = false;
}
```

可以看到，能配置的属性有一些常用的：javaCompileOptions、shrinkResources


####  javaCompileOptions

参考Java编译选项


#### shrinkResources

配置是否自动清理未使用的资源，默认false，方法原型
```java
    public void setShrinkResources(boolean shrinkResources) {
        checkPostProcessingConfiguration(PostProcessingConfiguration.OLD_DSL, "setShrinkResources");
        this.shrinkResources = shrinkResources;
    }
```


### 父类DefaultBuildType.java提供的属性

```java
public class DefaultBuildType extends BaseConfigImpl implements BuildType {
    private final String mName;
    private boolean mDebuggable = false;
    private boolean mJniDebuggable = false;
    private boolean mRenderscriptDebuggable = false;
    private int mRenderscriptOptimLevel = 3;
    private boolean mMinifyEnabled = false;
    private SigningConfig mSigningConfig = null;
    private boolean mEmbedMicroApp = true;
    private boolean mZipAlignEnabled = true;
    public DefaultBuildType(@NonNull String name) {
        mName = name;
    }
}
```

可以看到，能配置的属性有一些常用的：mDebuggable、mJniDebuggable、mMinifyEnabled、mSigningConfig、mZipAlignEnabled

#### mDebuggable

用于配置是否生成一个可供调试的 apk。值为false或者true。方法原型:
```java
    /** Whether this build type should generate a debuggable apk. */
    @NonNull
    public BuildType setDebuggable(boolean debuggable) {
        mDebuggable = debuggable;
        return this;
    }
```
因此，我们写的时候就是下面这样，他就自动会去调用 setDebuggable方法了
```
main {
   debuggable true
}
```

#### mJniDebuggable

用于配置是否生成一个供调试的JNI代码的APK

方法原型为：

```java
    /**
     * Whether this build type is configured to generate an APK with debuggable native code.
     */
    @NonNull
    public BuildType setJniDebuggable(boolean jniDebugBuild) {
        mJniDebuggable = jniDebugBuild;
        return this;
    }

```

#### mMinifyEnabled

用于配置该BuildType 是否启用 Proguard混淆，方法原型为：
```java
    /** Whether Minify is enabled for this build type. */
    @NonNull
    public BuildType setMinifyEnabled(boolean enabled) {
        mMinifyEnabled = enabled;
        return this;
    }
```

#### mSigningConfig

可以单独为某一个BuildType指定一个签名配置。对应的方法原型：
DefaultBuildType.java
```java
    /** Sets the signing configuration. e.g.: {@code signingConfig signingConfigs.myConfig} */
    @NonNull
    public BuildType setSigningConfig(@Nullable SigningConfig signingConfig) {
        mSigningConfig = signingConfig;
        return this;
    }
```

#### mZipAlignEnabled

zipAlign是Android Gradle 为我们提供的 整理优化 APK文件的工具，能够提高系统和应用的运行效率，更快的读写apk中的资源，降低内存使用。所以app发布前，一定要使用zipAlign优化一下。

配置 zipAlignEnabled 为true
```groovy
android {
   buildTypes {
      release {
         zipAlignEnabled true
      }
   }
}
```

对应的方法原型
```java
  /** Whether zipalign is enabled for this build type. */
    @NonNull
    public BuildType setZipAlignEnabled(boolean zipAlign) {
        mZipAlignEnabled = zipAlign;
        return this;
    }
```


### 在 父类BaseConfigImpl中，还有一些属性
```java
/**
 * An object that contain a BuildConfig configuration
 */
public abstract class BaseConfigImpl implements Serializable, BaseConfig {
    private final Map<String, ClassField> mBuildConfigFields = Maps.newTreeMap();
    private final Map<String, ClassField> mResValues = Maps.newTreeMap();
    private final List<File> mProguardFiles = Lists.newArrayList();
    private final List<File> mConsumerProguardFiles = Lists.newArrayList();
    private final List<File> mTestProguardFiles = Lists.newArrayList();
    private final Map<String, Object> mManifestPlaceholders = Maps.newHashMap();
    @Nullable
    private Boolean mMultiDexEnabled;
    @Nullable
    private File mMultiDexKeepProguard;
    @Nullable
    private File mMultiDexKeepFile;
}
```

#### mProguardFiles

配置该BuildTpe使用的混淆配置文件。提供了两个方法： proguardFile()用于指定一个配置文件； proguardFiles()可以指定多个配置文件。方法原型如下：
```java
    /**
     * Adds a new ProGuard configuration file.
     *
     * <p><code>proguardFile getDefaultProguardFile('proguard-android.txt')</code></p>
     *
     * <p>There are 2 default rules files
     * <ul>
     *     <li>proguard-android.txt
     *     <li>proguard-android-optimize.txt
     * </ul>
     * <p>They are located in the SDK. Using <code>getDefaultProguardFile(String filename)</code> will return the
     * full path to the files. They are identical except for enabling optimizations.
     */
    @NonNull
    public BuildType proguardFile(@NonNull Object proguardFile) {
        checkPostProcessingConfiguration(PostProcessingConfiguration.OLD_DSL, "proguardFile");
        getProguardFiles().add(project.file(proguardFile));
        return this;
    }

    /**
     * Adds new ProGuard configuration files.
     *
     * <p>There are 2 default rules files
     * <ul>
     *     <li>proguard-android.txt
     *     <li>proguard-android-optimize.txt
     * </ul>
     * <p>They are located in the SDK. Using <code>getDefaultProguardFile(String filename)</code> will return the
     * full path to the files. They are identical except for enabling optimizations.
     */
    @NonNull
    public BuildType proguardFiles(@NonNull Object... files) {
        checkPostProcessingConfiguration(PostProcessingConfiguration.OLD_DSL, "proguardFiles");
        for (Object file : files) {
            proguardFile(file);
        }
        return this;
    }
```

我们常常写的形式是：
```groovy
release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
```

getDefaultProguardFile() 方法，是 android(也就是AppExtension/BaseExtension)对象提供的方法。写全了是这样的： android.getDefaultProguardFile()，它的作用是获取Android SDK安装目录中， Android 为我们提供的默认的Proguard混淆配置文件， 路径是 Android SDK安装目录下的 tools/proguard。代码实现:

BaseExtension.java
```java
    public File getDefaultProguardFile(String name) {
        if (!ProguardFiles.KNOWN_FILE_NAMES.contains(name)) {
            extraModelInfo
                    .getSyncIssueHandler()
                    .reportError(
                            EvalIssueReporter.Type.GENERIC,
                            new EvalIssueException(ProguardFiles.UNKNOWN_FILENAME_MESSAGE));
        }
        return ProguardFiles.getDefaultProguardFile(name, project);
    }

```

从实现中可以看到，我们只要传递一个文件名给这个方法，就返回 tools/proguard下的文件。

Android SDK 为我们默认提供了两个Proguard配置文件。分别是：proguard-android.txt 和 proguard-android.optimize.txt。一个是没优化的，一个是优化的。

除了在BuildType中指定混淆，在defaultConfig中也可以指定。多渠道包 ProductFlavor也可以指定。

#### mManifestPlaceholders
参考动态配置 AndroidManifest 文件

#### mMultiDexEnabled

配置该 BuildType 是否启用自动查分多个Dex的功能。方法原型为：

```java
    public void setMultiDexEnabled(@Nullable Boolean multiDex) {
        mMultiDexEnabled = multiDex;
    }
```




## 使用混淆

步骤：
1. minifyEnabled 设置为 true
2. 配置 proguardFile 或者 proguardFiles

这两个属性，在buildType 和 defaultConfig里都可以配置的
TIP：个人觉得，最好把它写到一个BuildType里，对一个BuildType生效，比如release。不要放在defaultConfig里。如果放在defaultConfig里，设置开启，并且在 debug 里没显示关闭，那在调试的时候，偶尔可能会有问题。

## 共享库



## 批量修改APK文件名



## 修改 build 目录

直接修改project的buildDir属性即可：

app/build.gradle中
```groovy
project.buildDir = project.rootDir.absolutePath + "/xxxx"
```

这样就把之前的build目录全部迁移到了 xxxx 目录下

## 动态版本信息



## 动态配置 AndroidManifest 文件

## Java 编译选项

有时需对Java源代码的编码方式、Java的版本有要求，可以通过 compileOptions 方法来配置。

```groovy
android {
   compileOptions {
        sourceCompatibility = '1.8'
        targetCompatibility = '1.8'
   }
}
```

android对象（AppExtension/BaseExtension）对象提供了一个 compileOptions方法，接受一个CompileOptions类型的闭包作为参数，对java编译选项进行配置

BaseExtension.java

```java
    /**
     * Specifies Java compiler options, such as the language level of the Java source code and
     * generated bytecode.
     *
     * <p>For more information about the properties you can configure in this block, see {@link
     * com.android.build.gradle.internal.CompileOptions}.
     */
    public void compileOptions(Action<CompileOptions> action) {
        checkWritability();
        action.execute(compileOptions);
    }
```

明显，这个方法是编写嵌套 Extension 的写法。

CompileOptions 是编译配置，提供三个属性
```java
public class CompileOptions {
    private static final String VERSION_PREFIX = "VERSION_";

    @Nullable
    private JavaVersion sourceCompatibility;

    @Nullable
    private JavaVersion targetCompatibility;

    @NonNull
    private String encoding = Charsets.UTF_8.name();
```

* sourceCompatibility 是配置Java源代码的编译的版本。
方法源码：
```java
    /** @see #getSourceCompatibility() */
    public void setSourceCompatibility(@NonNull Object sourceCompatibility) {
        this.sourceCompatibility = convert(sourceCompatibility);
    }

```
可以看到，它接收一个 Object类型的参数，然后内部调用convert进行转换。看一下convert
```java

    /**
     * Converts all possible supported way of specifying a Java version to a {@link JavaVersion}.

     * 尽可能将所有支持的方式转换成JavaVersion对象
     * @param version the user provided java version.
     */
    @NonNull
    private static JavaVersion convert(@NonNull Object version) {
        // for backward version reasons, we support setting strings like 'Version_1_6'
        if (version instanceof String) {
            final String versionString = (String) version;
            if (versionString.toUpperCase(Locale.ENGLISH).startsWith(VERSION_PREFIX)) {
                version = versionString.substring(VERSION_PREFIX.length()).replace('_', '.');
            }
        }
        return JavaVersion.toVersion(version);
    }
```

这个convert方法，会尽可能将所有支持的方式转换成JavaVersion对象。下面我们列出可用的值：
* 1.8
* "1.8" 或者 '1.8'  都是String
* JavaVersion.Version_1_8
* Version_1_8

* targetCompatibility 是配置生成的Java字节码的版本。


# Android Gradle 任务

Android Gradle 插件是基于 Java 插件的，因此Android Gradle 插件包含了所有的Java插件提供的功能，包括 assemble， build 等。除此之外，Android还添加了install， lint等任务

常用的：

* connectedCheck 在所有的连接的设备或者模拟器上进行check检查

* lint 在所有的ProductFlavor上运行 lint检查

* assemble、assembleRelease、assembleDebug 打包构建

* build

* clean

* install

完。


